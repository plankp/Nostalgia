;;
;; Contains functions that write to the graphics buffer
;;
;; Note: Do not compile this alone. Always include it as part of another file.
;;

;;
;; Calculates the video memory offset (so you can ldst the result and it will
;; access the corresponding cell directly!). If the memory is illegal, then 0
;; is returned!
;;
;; %R1H = MODIFIED x coordinate
;; %R1L = MODIFIED y coordinate
;;
;; %R1  = RETURN
;;
    .ALIGN  2
VID_OFFSET:
    PUSH    %R3, 0

    MOV.I   %R3, 80             ; 2 * (y * 80 + x)
    MUL     %R0, %R3, %R3, %R1L
    ADD.R   %R3, %R3, %R1H
    SHL.I   %R3, 1

    ; At this point, %R3 can only be valid if it's within 0 and 0xFA0.
    OR.R    %R1, %R3, %R0       ; copy %R3 to %R1
    JREL.LT %R3, +12            ; if %R3 < 0
    SUB.I   %R3, 0xFA0          ; if %R3 >= 0xFA0
    JREL.GE %R3, +6
    ADD.I   %R1, 0x2000         ; rebase %R1 (old %R3) to graphics buffer
    JREL.Z  %R0, +2
    MOV.I   %R1, 0              ; %R3 was invalid, return 0

    POP     %R3, 0
    RET

;;
;; Draws a glyph onto the screen at the given location. This is not the same as
;; drawing a character. Example: glyph of 0xA is this rectangular box with a
;; circle; char of 0xA is a newline (so nothing is printed)!
;;
;; If the coordinate is invalid, then nothing is drawn (also no error).
;;
;; %R1H = x coordinate
;; %R1L = y coordinate
;; %R2L = glyph index
;;
    .ALIGN  2
DRAW_GLYPH:
    PUSH    %R1, 0
    CALL    VID_OFFSET
    JREL.Z  %R1, +2             ; skip illegal coordinates
    ST.B    %R2, 0, %R1         ; ST.B automatically uses %R2L
    POP     %R1, 0
    RET

;;
;; Sets the rendering style of the given graphics cell.
;;
;; If the coordinate is invalid, then nothing is changed (also no error).
;;
;; %R1H = x coordinate
;; %R1L = y coordinate
;; %R2L = rendering style
;;
    .ALIGN  2
DRAW_STYLE:
    PUSH    %R1, 0
    CALL    VID_OFFSET
    JREL.Z  %R1, +2             ; skip illegal coordinates
    ST.B    %R2, 1, %R1         ; ST.B automatically uses %R2L
    POP     %R1, 0
    RET
