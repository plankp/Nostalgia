;;
;; This is what happens when you do not load a proper kernel! It's a kernel
;; that tells you to load an actual kernel!
;;
;; Jokes aside, this is for the assembler to work in a non-miserable way. The
;; idea is that you provide the kernel assembler code when you run this virtual
;; machine, and if an error happens, you'd be able to see it on the screen
;; (because of this file)
;;

    .ORG 0x4000

    .SET    VIDMEM, 0x2000

    OR.R    %R1, %R0, %R0
    OR.R    %R3, %R0, %R0
PRINT_LOOP:
    LD.B    %R2, ERR_MSG, %R1   ; load char
    JREL.Z  %R2, -4             ; that was the last character, so hang
    MOV.I   %R4, 0x0A           ; handle line feed character ('\n')
    SUB.R   %R4, %R4, %R2
    JABS.Z  %R4, PRINT_NEWLINE
PRINT_CHAR:
    ST.B    %R2, VIDMEM, %R3    ; print char
    ADD.I   %R3, 2              ; increment vidmem offset
    JABS.Z  %R0, POST_INC
PRINT_NEWLINE:
    MOV.I   %R4, 160            ; 80 * 2
    DIV     %R3, %R0, %R3, %R4
    ADD.I   %R3, 1
    MUL     %R0, %R3, %R3, %R4
POST_INC:
    ADD.I   %R1, 1              ; increment string offset
    JABS.Z  %R0, PRINT_LOOP     ; ready to print next char

    .ZERO 0x200
ERR_MSG:
    .EMIT   0x41,0x74,0x6f,0x69,0x6b,0x73,0x20,0x47,0x61,0x6d,0x65,0x73,0x20
    .EMIT   0x2d,0x20,0x4e,0x6f,0x73,0x74,0x61,0x6c,0x67,0x69,0x61,0x2e,0x2e
    .EMIT   0x2e,0x0a,0x0a,0x48,0x6d,0x6d,0x2e,0x2e,0x2e,0x20,0x4c,0x6f,0x6f
    .EMIT   0x6b,0x73,0x20,0x6c,0x69,0x6b,0x65,0x20,0x79,0x6f,0x75,0x20,0x68
    .EMIT   0x61,0x76,0x65,0x6e,0x27,0x74,0x20,0x6c,0x6f,0x61,0x64,0x65,0x64
    .EMIT   0x20,0x61,0x20,0x6b,0x65,0x72,0x6e,0x65,0x6c,0x20,0x79,0x65,0x74
    .EMIT   0x21,0x0a,0x28,0x59,0x6f,0x75,0x20,0x73,0x68,0x6f,0x75,0x6c,0x64
    .EMIT   0x20,0x64,0x6f,0x20,0x74,0x68,0x61,0x74,0x29,0x20,0x01
    .EMIT   0x00